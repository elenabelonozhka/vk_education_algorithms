#1 Максимальная сумма подмассива 
#используем скользящее окно
def maxSubarraySum(arr, k):
  if (len(arr) < k):
    return None
  
  currentSum = 0
  for i in range(k):
    currentSum += arr[i]
  
  maxSum = currentSum
  for i in range(k,len(arr)):
    currentSum = currentSum - arr[i - k] + arr[i]
    maxSum = max(maxSum, currentSum)

  return maxSum

maxSubarraySum([1,2,3], 2) #5



############################################################################



#2 subarray sum equals k
def subarray_sum(nums: list[int], k: int) -> int:
    prefix_sum = 0
    # Инициализация: префиксная сумма 0 встречается 1 раз
    prefix_count = {0: 1}
    count = 0

    for num in nums:
        prefix_sum += num
        # Проверяем, есть ли в prefix_count значение prefix_sum - k
        if (prefix_sum - k) in prefix_count:
            count += prefix_count[prefix_sum - k]
        # Обновляем словарь для текущей префиксной суммы
        prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1

    return count

subarray_sum([1,11,-1,0], 11) #3



############################################################################




#3 Максимальная длина подмассива с равным количеством 0 и 1
def find_max_length(nums: list[int]) -> int:
    prefix_sum = 0
    max_len = 0
    # Инициализация: сумма 0 встречается на позиции -1 (перед началом массива)
    index_map = {0: -1}

    for i, num in enumerate(nums):
        # Заменяем 0 на -1, 1 оставляем как +1
        prefix_sum += -1 if num == 0 else 1

        if prefix_sum in index_map:
            # Если сумма уже встречалась, обновляем max_len
            max_len = max(max_len, i - index_map[prefix_sum])
        else:
            # Иначе сохраняем первую позицию для этой суммы
            index_map[prefix_sum] = i

    return max_len

find_max_length([0,1,0,1,0]) #4




################################################################################



#4 индекс поворота массива (индекс, где сумма всех чисел строго слева от индекса равна сумме чисел строго от правго индекса)
def pivot_index(nums: list[int]) -> int:
    total_sum = 0
    left_sum = 0

    # Вычисляем общую сумму элементов массива
    for num in nums:
        total_sum += num

    # Проверяем каждый индекс, чтобы найти пивот
    for i, num in enumerate(nums):
        # Проверяем, является ли текущий индекс пивотом
        # total_sum - left_sum - nums[i] - это сумма элементов справа
        if left_sum == total_sum - left_sum - num:
            return i  # Возвращаем индекс, если нашли пивот
        # Обновляем left_sum для следующего индекса
        left_sum += num

    return -1  # Если пивот не найден, возвращаем -1



pivot_index([9,4,8,100,1,11,2,6,1]) #3



################################################################################



#5 баланс скобок через префиксные суммы
def can_make_valid_with_deletions(s: str, k: int) -> bool:
    balance = 0  # Текущий баланс открывающих скобок
    extra_closed_balance = 0  # Количество лишних закрывающих скобок

    for char in s:
        if char == '(':
            balance += 1
        else:  # char == ')'
            if balance > 0:
                balance -= 1
            else:
                extra_closed_balance += 1

    total_needed = balance + extra_closed_balance
    return total_needed <= k


can_make_valid_with_deletions(')())', 1) # False
