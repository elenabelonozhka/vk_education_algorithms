# Two sum
# Дан отсортированный по возрастанию массив целых чисел и некоторое число target.
# Необходимо найти два числа в массиве, которые в сумме дают заданное значение target, и вернуть их индексы.

def twoSum(nums, target):
	left = 0
	right = len(nums) - 1
	while (left < right):
		sum = nums[left] + nums[right]
		if (sum == target):
			return [left, right]
		elif (sum < target):
			left += 1
		else:
			right -= 1
	return []

twoSum([1,2,5,6,10], 15)


#Развернуть массив
# Дан массив целых чисел. Необходимо развернуть его.
# Сделать это надо за линейное время без дополнительных аллокаций.
#идея: своп концов
def reverseArray(arr):
	left = 0
	right = len(arr) - 1
	while (left < right):
		arr[left], arr[right] = arr[right], arr[left]
		left += 1
		right -= 1
	return arr

reverseArray([1,2,3])


# Развернуть часть массива
# Дан массив целых чисел.
# Необходимо развернуть справа налево часть массива, которая указана вторым параметром.
# Сделать это надо за линейное время без дополнительных аллокаций
# *я бы сформулировала не развернуть, а переместить
# идея: 3 применения функции-разворачивания

def reverseArray(arr, left, right):
	while (left < right):
		arr[left], arr[right] = arr[right], arr[left]
		left += 1
		right -= 1

def solution(arr, k):
	n = len(arr)
	reverseArray(arr, 0, n - 1)
	reverseArray(arr, 0, k%n - 1)
	reverseArray(arr, k%n, n - 1)
	return arr

arr = [1,2,3,4,5,6,7]
k = 10
arr
solution(arr, k)



# Слияние двух отсортированных массивов.
# Без дополнительных аллокаций
# Дано два отсортированных массива. Необходимо написать функцию, которая объединит эти два массива в один отсортированный.
# Первый массив имеет размер, равный результирующиму массиву, значения в конце равны нулям. Мы не должны создавать третий массив.
# идея: три указателя. заполнять слева направо 'большими значениями

def merge(arr1, arr2):
	pointer1 = len(arr1) - len(arr2) - 1
	pointer2 = len(arr2) - 1
	pointer3 = len(arr1) - 1
	while pointer2 >= 0:
		if pointer1 >= 0 and arr1[pointer1] > arr2[pointer2]:
			arr1[pointer3] = arr1[pointer1]
			pointer1 -= 1
		else:
			arr1[pointer3] = arr2[pointer2]
			pointer2 -= 1
		pointer3 -= 1
	return arr1

merge([3,8,10,11,0,0,0], [1,7,9])




#Сортировка массива из 0 и 1
# Дан массив, содержащий только 0 и 1.
# Напишите функцию, которая сортирует его так, чтобы все нули оказались в начале, а все единички — в конце.
# Решение должно быть in-place.
# идея: свапаем, пока левый не ноль
def sort_binary_array(arr):
	left, right = 0, len(arr) - 1
	while left < right:
		if arr[left] == 1:
			arr[left], arr[right] = arr[right], arr[left]
			right -= 1
		else:
			left += 1
	return arr

sort_binary_array([0,1,0,1,0])




#Задача флага Нидерландов
# Дан массив состоящий из нулей,единиц и двоек
# Необходимо его отсортировать за линейное время
# идея: справа от high отсортированный массив (двойки, если они есть). Представлять картинку

def sortColors(nums):
	low = 0
	mid = 0
	high = len(nums) - 1
	while (mid <= high):
		if (nums[mid] == 0):
			nums[low], nums[mid] = nums[mid], nums[low]
			low += 1
			mid += 1
		elif (nums[mid] == 1):
			mid += 1
		elif (nums[mid] == 2):
			nums[mid], nums[high] = nums[high], nums[mid]
			high -= 1

nums =  [2,0,1,0,1,2]  
sortColors(nums)
nums




#Передвинуть четные числа вперед
# Дан не отсортированный массив целых чисел. Необходимо перенести в начало массива все четные числа, сохраняя их очередность
# То есть если 8 стояла после 2, то после переноса в начало, он по-прежнему должна стоять после 2

def evenFirst(arr):
	evenIndex = 0
	for i in range(len(arr)):
		if arr[i] % 2 == 0:
			arr[i], arr[evenIndex] = arr[evenIndex], arr[i]
			evenIndex += 1
	return arr
  
evenFirst([7,3,4,8,5,11,12,2])




#Нули в конец
#В школе прошел экзамен по математике. Несколько человек списали решенияи были замечены. 
#Этим школьникам поставил 0 баллов.
#Задача: есть массив с оценками, среди которых есть 0. Необходимо все оценки, равные нулю, 
#перенести в конец массива, чтобы все такие школьники оказались в конце списка. 

# без сохранения порядка, идем справа налево
def shoolmarks_no_order(arr):
	wantbe0 = len(arr)-1
	for i in range(len(arr)-1,-1,-1):
		if arr[i] == 0:
			arr[i], arr[wantbe0] = arr[wantbe0], arr[i]
			wantbe0 -= 1
	return arr
shoolmarks_no_order([0, 0, 0, 18, 16, 0, 0, 77, 99])

#с сохранением порядка
#notnull = четные
def shoolmarks(arr):
	notnull = 0
	for i in range(len(arr)):
		if arr[i] != 0:
			arr[i], arr[notnull] = arr[notnull], arr[i]
			notnull += 1
	return arr
shoolmarks([0, 33, 57, 88, 60, 0, 0, 80, 99])
