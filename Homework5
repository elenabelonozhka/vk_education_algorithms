#1 Проверка корректности max кучи
#i in range((n - 2) // 2), так как 2*i + 1 < n
def isMaxHeap(arr):
  n = len(arr)

  for i in range((n - 2) // 2):
    left = 2 * i + 1
    right = 2 * i + 2
    if (left < n and arr[i] < arr[left]):
      return False
    if (right < n and arr[i] < arr[right]):
      return False

  return True

arr = [11,10,9,8]

isMaxHeap(arr)
#True




#2 Проверка корректности max кучи BFS
#(предыдущее решение лучше - не выделяем память под очередь, проверяем не все узлы, а только родителей)
def isMaxHeap(arr):
  n = len(arr)
  if (n <= 1):
    return True

  # Используем очередь для BFS обхода
  queue = []
  queue.append(0) # начинаем с корня

  while (len(queue) > 0):
    i = queue.pop()
    left = 2 * i + 1
    right = 2 * i + 2
    # Проверяем левого потомка
    if (left < n):
      if (arr[i] < arr[left]):
        return False
      queue.append(left)

    # Проверяем правого потомка
    if (right < n):
      if (arr[i] < arr[right]):
        return False
      queue.append(right)


  return True

arr = [11,10,9,8]

isMaxHeap(arr)
#True



#3 Проверка корректности кучи BFS с флагом (дан корень дерева)
#Проходимся только по родителям благодаря флагу shouldBeLeaf
def isMaxHeap(root):
    if not root:
        return True

    # Очередь для обхода дерева в ширину (BFS)
    queue = [root]
    shouldBeLeaf = False

    while queue:
        current = queue.pop(0)

        # Проверяем левый потомок
        if current.left:
            if shouldBeLeaf or current.left.val > current.val:
                return False
            queue.append(current.left)
        else:
            shouldBeLeaf = True  # Все следующие узлы должны быть листьями

        # Проверяем правый потомок
        if current.right:
            if shouldBeLeaf or current.right.val > current.val:
                return False
            queue.append(current.right)
        else:
            shouldBeLeaf = True  # Все следующие узлы должны быть листьями

    return True

  buildTree([8,9,11,7,16,3,1], 0)




#4 Проверка корректности кучи BFS с флагом (дан корень дерева)
#Проходимся только по родителям благодаря флагу shouldBeLeaf
def isMaxHeap(root):
    if not root:
        return True

    # Очередь для обхода дерева в ширину (BFS)
    queue = [root]
    shouldBeLeaf = False

    while queue:
        current = queue.pop(0)

        # Проверяем левый потомок
        if current.left:
            if shouldBeLeaf or current.left.data > current.data:
                return False
            queue.append(current.left)
        else:
            shouldBeLeaf = True  # Все следующие узлы должны быть листьями

        # Проверяем правый потомок
        if current.right:
            if shouldBeLeaf or current.right.data > current.data:
                return False
            queue.append(current.right)
        else:
            shouldBeLeaf = True  # Все следующие узлы должны быть листьями

    return True

isMaxHeap(buildTree([3,2,1,-1,1,3], 0))




#5 Полное бинарное дерево
def isCompleteTree(root):
  if not root:
    return True

  queue = [root]
  shouldBeLeaf = False

  while queue:
    node = queue.pop(0)

    if not node:
      shouldBeLeaf = True
    else:
      if shouldBeLeaf:
        return False
      queue.append(node.left)
      queue.append(node.right)

  return True

root = TreeNode(1)

# Создание узлов-потомков
left_child = TreeNode(2)
right_child = TreeNode(3)

# Связывание потомков с корневым узлом
root.right = right_child

isCompleteTree(root)




#6 Объединение K отсортированных массивов

#Реализация класса MinHeap

class MinHeap:
  def __init__(self):
    self.heap = []

  def parent(self, i):
    if i == 0:
      return i
    return (i - 1) // 2

  def left_child(self, i):
    return 2 * i + 1

  def right_child(self, i):
    return 2 * i + 2

  def is_empty(self):
    return len(self.heap) == 0

  def size(self):
    return len(self.heap)

  def swap(self, i, j):
    self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

  def up(self, i):
    #Поднимаем элемент вверх, восстанавливая свойства min-кучи
    while self.heap[i] < self.heap[self.parent(i)]:
      self.swap(i, self.parent(i))
      i = self.parent(i)

  def sift_down(self, i):
    #Опускаем элемент вниз, восстанавливая свойства min-кучи
    n = self.size()
    while True:
      left = self.left_child(i)
      right = self.right_child(i)
      smallest = i

      if left < n and self.heap[left] < self.heap[smallest]:
        smallest = left
      if right < n and self.heap[right] < self.heap[smallest]:
        smallest = right

      if smallest != i:
        self.swap(i, smallest)
        i = smallest
      else:
        break

  def push(self, value):
    # Добавление элемента в кучу
    # Добавляем в конец (следующая позиция в нижнем уровне)
    self.heap.append(value)
    # Поднимаем элемент
    self.up(len(self.heap) - 1)

  def pop(self):
    #Извлечение минимального элемента
    if self.is_empty():
      return None

    # Сохраняем минимальный элемент (корень)
    min_value = self.heap[0]

    if self.size() == 1:
      self.heap.pop()
      return min_value

    # Заменяем корень последним элементом
    self.heap[0] = self.heap.pop()
    # Опускаем новый корень на нужную позицию
    self.sift_down(0)

    return min_value

#Искомая функция
def merge_k_sorted_arrays(sorted_arrays):
  # Итоговый массив
  merged_array = []
  # Минимальная куча
  min_heap = MinHeap()

  # Инициализируем кучу с первым элементом каждого массива
  for i in range(len(sorted_arrays)):
    current_array = sorted_arrays[i]
    # Проверяем, что массив не пустой
    if len(current_array) > 0:
      # (значение, индекс массива, индекс элемента)
      min_heap.push((current_array[0], i, 0))

  # Пока куча не пуста
  while not min_heap.is_empty():
    # Извлекаем наименьший элемент из кучи
    value, array_idx, element_idx = min_heap.pop()
    # Добавляем его в итоговый массив
    merged_array.append(value)

    # Проверяем, есть ли следующий элемент в том же массиве
    if element_idx + 1 < len(sorted_arrays[array_idx]):
      # Добавляем следующий элемент этого массива в кучу
      next_element = sorted_arrays[array_idx][element_idx + 1]
      min_heap.push((next_element, array_idx, element_idx + 1))

  return merged_array

merge_k_sorted_arrays([[1,4,5],[1,3,4],[2,6],[-8,100]])




#7 К-ый наименьший элемент в BST
class TreeNode:
  def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right

def inorderMinIterative(node, k):
  if not node or k <= 0:
    return None

  stack = []
  counter = 0
  current = node

  while stack or current:
    # Спускаемся влево
    while current:
      stack.append(current)
      current = current.left

    # Поднимаемся и обрабатываем узел
    current = stack.pop()
    counter += 1

    if counter == k:
      return current.val

    # Переходим к правому поддереву
    current = current.right

  return None


root = TreeNode(16)

# Создание узлов-потомков
left_child = TreeNode(10)
right_child = TreeNode(22)

# Связывание потомков с корневым узлом
root.right = right_child
root.left = left_child

inorderMinIterative(root, 3)




#8.0 К-ый наименьший элемент в BST (рекурсивный подход) НЕРАБОЧИЙ
def inorder_min(node, k, counter):
  if node is None:
    return None
  
  # Обход левого поддерева
  left_result = inorder_min(node.left, k, counter)
  if left_result is not None:
    return left_result, counter
  
  # Увеличиваем счетчик и проверяем
  counter += 1
  if counter == k:
    return node.val, counter
  
  # Обход правого поддерева
  return inorder_min(node.right, k, counter)

root = TreeNode(16)

# Создание узлов-потомков
left_child = TreeNode(10)
right_child = TreeNode(22)

# Связывание потомков с корневым узлом
root.right = right_child
root.left = left_child

inorder_min(root, 2,0)
#Вывод (22,2) - неверно




#8 К-ый наименьший элемент в BST (рекурсивный подход)
def inorder_min(node, k, counter):
  if node is None:
    return None, counter[0] # Возвращаем текущее значение счетчика
  
  # Обход левого поддерева
  left_result = inorder_min(node.left, k, counter)
  if left_result[0] is not None:
    return left_result[0], counter[0]
  
  # Увеличиваем счетчик и проверяем
  counter[0] += 1
  if counter[0] == k:
    return node.val, counter[0]
  
  # Обход правого поддерева
  return inorder_min(node.right, k, counter)

root = TreeNode(16)
left_child = TreeNode(10)
right_child = TreeNode(22)
root.right = right_child
root.left = left_child

inorder_min(root, 2, [0])  # Передаем список 
#вывод (16,2) - верно




#9 Balance factor
class TreeNode:
  def __init__(self, val=0, left=None, right=None):
    self.val = val
    self.left = left
    self.right = right
    self.balance_factor = 0 # Добавляем поле для баланс-фактора

def calculate_heights_and_balance(node):
  if node is None:
    return 0
  
  left_height = calculate_heights_and_balance(node.left)
  right_height = calculate_heights_and_balance(node.right)
  
  node.balance_factor = left_height - right_height
  #Возвращаем высоту текущего поддерева
  return 1 + max(left_height, right_height)

root = TreeNode(16)
left_child = TreeNode(10)
right_child = TreeNode(22)
left_child2 = TreeNode(8)
root.right = right_child
root.left = left_child
root.left.left = left_child2

calculate_heights_and_balance(root) #3
root.balance_factor #1




#10 Преобразование в зеркальное дерево (рекурсивно)
def mirrorTree(node):
  if (node == None):
    return None

  node.left, node.right = node.right, node.left
  mirrorTree(node.left)
  mirrorTree(node.right)
  return node


root = TreeNode(16)
left_child = TreeNode(10)
right_child = TreeNode(22)
left_child2 = TreeNode(8)
root.right = right_child
root.left = left_child
root.left.left = left_child2

mirrorTree(root).right.right.val #8



#11 Преобразование в зеркальное дерево (итеративно)
def mirror_tree_iterative(node):
  if node is None:
    return None
  
  # Используем стек для обхода (LIFO)
  stack = [node]
  
  while stack:
    current = stack.pop()
    
    # Меняем местами левый и правый дочерние узлы
    current.left, current.right = current.right, current.left
    
    # Добавляем в стек дочерние узлы
    if current.left:
      stack.append(current.left)
    if current.right:
      stack.append(current.right)
  
  return node


root = TreeNode(16)
left_child = TreeNode(10)
right_child = TreeNode(22)
left_child2 = TreeNode(8)
root.right = right_child
root.left = left_child
root.left.left = left_child2

mirror_tree_iterative(root).right.right.val #8
