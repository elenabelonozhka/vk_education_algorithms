#1 Восстановление дерева из массива (для полного бинарного дерева)
class TreeNode:
  def __init__(self, val = 0, left = None, right = None):
    self.data = val
    self.left = left
    self.right = right

root = TreeNode(1)

# Создание узлов-потомков
left_child = TreeNode(2)
right_child = TreeNode(3)

# Связывание потомков с корневым узлом
root.left = left_child
root.right = right_child

#искомая функция
def buildTree(arr, i):
  if i >= len(arr):
    return None

  root = TreeNode(arr[i])
  root.left = buildTree(arr, 2 * i + 1)
  root.right = buildTree(arr, 2 * i + 2)

  return root

buildTree([8,9,11,7,16,3,1], 0).left.right.data
#output: 16



#2 Симметричное дерево BFS

def isSymmetric(root):
  if root == None:
    return True

  queue = [root]
  while (len(queue) > 0):
    queueLen = len(queue);
    for i in range(queueLen):
      #queue[queueLen - i - 1] - симметричный
      #относительно узла queue[i]
      if (queue[i] == None and queue[queueLen - i - 1] == None):
        continue
      if (queue[i] == None or queue[queueLen - i - 1] == None):
        return False
      if (queue[i].data != queue[queueLen - i - 1].data):
        return False

      queue.append(queue[i].left)
      queue.append(queue[i].right)

    queue = queue[queueLen:]

  return True


isSymmetric(buildTree([8,9,9,11,10,10,11], 0))



#3 Симметричное дерево DFS (Depth-First Search)
#Используем LNR - получим массив = проекция на горизонталь. Если массив является палиндромом, то дерево симметрично

#LNR обход
def deptSearch(root, res):
  if root == None:
    return res
    
  deptSearch(root.left, res)
  res.append(root.data)
  deptSearch(root.right, res)

  return res

res = []
deptSearch(buildTree([8,9,9,11,10,10,11], 0), res)
#output: [11, 9, 10, 8, 10, 9, 11]

def isSymmetricDFS(root):
  if root == None:
    return True

  data = []
  data = deptSearch(root, data)
  j = len(data) - 1
  for i in range(len(data)//2):
    if data[i] != data[j]:
      return False
    j -= 1

  return True

isSymmetricDFS(buildTree([8,9,9,11,10,10,11], 0))



#4 Поиск минимальной глубины бинарного дерева DFS

def minDepth(root):
  if root == None:
    return 0

  if root.left == None and root.right == None:
    return 1

  if root.left != None and root.right != None:
    return 1 + min(minDepth(root.left), minDepth(root.right))

  if root.left != None:
    return 1 + minDepth(root.left)

  if root.right != None:
    return 1 + minDepth(root.right)

minDepth(buildTree([8,9,9,11,10], 0))    



#5 Поиск произведения максимального и минимального элементов (по полному бинарному дереву поиска в виде массива)

def maxMinMultiplication(data):
  if len(data) < 3:
    return -1

  min_index = 1
  max_index = 2
  i = 0
  while True:
    min_index_tmp = 2 * i + 1
    if min_index_tmp < len(data):
      min_index = min_index_tmp
      i = min_index_tmp
      continue
    break

  while True:
    max_index_tmp = 2 * i + 2
    if max_index_tmp < len(data):
      max_index = max_index_tmp
      i = max_index_tmp
      continue
    break

  result = data[min_index] * data[max_index]
  return result

maxMinMultiplication([5,7,9,6,8]) 



#6 Сравнение двух бинарных деревьев

def isSameTree(a, b):
  if a == None and b == None:
    return True

  if a == None or b == None:
    return False

  if a.data != b.data:
    return False

  return isSameTree(a.left, b.left) and isSameTree(a.right, b.right)

isSameTree(buildTree([8,9,9,11,10], 0), buildTree([8,9,9,11,10], 0))
